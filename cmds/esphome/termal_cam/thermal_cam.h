#ifndef __WLED_BOARD_H__
#define __WLED_BOARD_H__

static uint16_t* heatmap_buf = nullptr;

static const uint16_t ironbow[256] = {
    0x0000, 0x0000, 0x0001, 0x0001, 0x0002, 0x0002, 0x0003, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007, 0x0008, 0x0009, 0x000a, 0x000b,
    0x000c, 0x000d, 0x000f, 0x100f, 0x1010, 0x1011, 0x2012, 0x2013, 0x3014, 0x3015, 0x4016, 0x4017, 0x5018, 0x5019, 0x601a, 0x601b,
    0x701c, 0x801d, 0x801e, 0x901f, 0x981f, 0xa01f, 0xa81f, 0xb01f, 0xb81f, 0xc01f, 0xc81f, 0xd01f, 0xd81f, 0xe01f, 0xe81f, 0xf01f,
    0xf81f, 0xf81e, 0xf81d, 0xf81c, 0xf81b, 0xf81a, 0xf819, 0xf818, 0xf817, 0xf816, 0xf815, 0xf814, 0xf813, 0xf812, 0xf811, 0xf810,
    0xf80f, 0xf80e, 0xf80d, 0xf80c, 0xf80b, 0xf80a, 0xf809, 0xf808, 0xf807, 0xf806, 0xf805, 0xf804, 0xf803, 0xf802, 0xf801, 0xf800,
    0xf800, 0xf000, 0xe800, 0xe000, 0xd800, 0xd000, 0xc800, 0xc000, 0xb800, 0xb000, 0xa800, 0xa000, 0x9800, 0x9000, 0x8800, 0x8000,
    0x7800, 0x7000, 0x6800, 0x6000, 0x5800, 0x5000, 0x4800, 0x4000, 0x3800, 0x3000, 0x2800, 0x2000, 0x1800, 0x1000, 0x0800, 0x0000,
    0x0020, 0x0040, 0x0060, 0x0080, 0x00a0, 0x00c0, 0x00e0, 0x0100, 0x0120, 0x0140, 0x0160, 0x0180, 0x01a0, 0x01c0, 0x01e0, 0x0200,
    0x0220, 0x0240, 0x0260, 0x0280, 0x02a0, 0x02c0, 0x02e0, 0x0300, 0x0320, 0x0340, 0x0360, 0x0380, 0x03a0, 0x03c0, 0x03e0, 0x0400,
    0x0420, 0x0440, 0x0460, 0x0480, 0x04a0, 0x04c0, 0x04e0, 0x0500, 0x0520, 0x0540, 0x0560, 0x0580, 0x05a0, 0x05c0, 0x05e0, 0x0600,
    0x0620, 0x0640, 0x0660, 0x0680, 0x06a0, 0x06c0, 0x06e0, 0x0700, 0x0720, 0x0740, 0x0760, 0x0780, 0x07a0, 0x07c0, 0x07e0, 0x0800,
    0x0810, 0x0820, 0x0830, 0x0840, 0x0850, 0x0860, 0x0870, 0x0880, 0x0890, 0x08a0, 0x08b0, 0x08c0, 0x08d0, 0x08e0, 0x08f0, 0x0900,
    0x1100, 0x1900, 0x2100, 0x2900, 0x3100, 0x3900, 0x4100, 0x4900, 0x5100, 0x5900, 0x6100, 0x6900, 0x7100, 0x7900, 0x8100, 0x8900,
    0x9100, 0x9900, 0xa100, 0xa900, 0xb100, 0xb900, 0xc100, 0xc900, 0xd100, 0xd900, 0xe100, 0xe900, 0xf100, 0xf900, 0xf920, 0xf940,
    0xf960, 0xf980, 0xf9a0, 0xf9c0, 0xf9e0, 0xfa00, 0xfa20, 0xfa40, 0xfa60, 0xfa80, 0xfaa0, 0xfac0, 0xfae0, 0xfb00, 0xfb20, 0xfb40,
    0xfb60, 0xfb80, 0xfba0, 0xfbc0, 0xfbe0, 0xfc00, 0xfc20, 0xfc40, 0xfc60, 0xfc80, 0xfca0, 0xfcc0, 0xfce0, 0xfd00, 0xfff0, 0xffff
};

void generate_heat_map(void)
{
    if (!termal->is_data_ready())
        return;

    float *raw_temps = termal->get_raw_pixels();

    // 1. Define dimensions for the rotated buffer
    // Sensor is 32x24. We interpolate to 80x60 (90 deg rotated)
    const int out_w = 60; 
    const int out_h = 80;

    if (heatmap_buf == nullptr) {
        heatmap_buf = (uint16_t*) heap_caps_malloc(out_w * out_h * 2, MALLOC_CAP_SPIRAM);
    }

    float min_t = id(min_temp).state;
    float max_t = id(max_temp).state;
    float inv_range = (max_t != min_t) ? (255.0f / (max_t - min_t)) : 0.0f;

    for (int y = 0; y < out_h; y++) {
        for (int x = 0; x < out_w; x++) {
            
            // --- 90Â° CLOCKWISE ROTATION + INTERPOLATION ---
            float gy = x * (23.0f / (out_w - 1)); 
            float gx = y * (31.0f / (out_h - 1));

            int x0 = (int)gx;
            int x1 = (x0 < 31) ? x0 + 1 : 31;
            float dx = gx - x0;

            int y0 = (int)gy;
            int y1 = (y0 < 23) ? y0 + 1 : 23;
            float dy = gy - y0;

            float p00 = raw_temps[y0 * 32 + x0];
            float p10 = raw_temps[y0 * 32 + x1];
            float p01 = raw_temps[y1 * 32 + x0];
            float p11 = raw_temps[y1 * 32 + x1];

            float temp = p00 * (1.0f - dx) * (1.0f - dy) +
                         p10 * dx * (1.0f - dy) +
                         p01 * (1.0f - dx) * dy +
                         p11 * dx * dy;

            int color_idx = (int)((temp - min_t) * inv_range);
            if (color_idx < 0) color_idx = 0;
            if (color_idx > 255) color_idx = 255;
            
            uint16_t c = ironbow[color_idx];
            // Swap bytes for SPI Display and store
            heatmap_buf[y * out_w + x] = (c << 8) | (c >> 8);
        }
    }

    static lv_img_dsc_t dsc;
    dsc.header.always_zero = 0;
    dsc.header.w = out_w;   
    dsc.header.h = out_h;   
    dsc.header.cf = LV_IMG_CF_TRUE_COLOR;
    dsc.data = (uint8_t*)heatmap_buf;
    dsc.data_size = out_w * out_h * 2;

    // --- LVGL STYLING TO PREVENT TILING ---
    
    // Set source
    lv_img_set_src(thermal_img, &dsc);

    // Set the widget size to match buffer (Prevents tiling)
    lv_obj_set_size(thermal_img, out_w, out_h);

    // Zoom 6x (256 * 6 = 1536) 
    // This makes the 60x80 buffer appear as 360x480 on screen
    lv_img_set_zoom(thermal_img, 1536);

    // Set pivot to center of the 60x80 buffer
    lv_img_set_pivot(thermal_img, out_w / 2, out_h / 2);

    // Keep the widget in the center of the screen
    lv_obj_center(thermal_img);

    lv_obj_invalidate(thermal_img);
}
#endif